
# ecommerce-assessment


### For Full Product Documentation visit this Link [Documentation](https://github.com/MohammedHydr/ecommerce-assessment/blob/master/Technical%20Assesment%20Documentation.pdf)
### Demo 
### [Video Recording](https://drive.google.com/file/d/1nX2sBWIah2YV_pmTOdj6xA3NiIXHEZFV/view?usp=sharing)
The video shows the full runnig project on my local machine as a testing environment

## CQRS
![image](https://github.com/MohammedHydr/ecommerce-assessment/assets/93540731/c34cf453-24c1-47a1-83f7-eb3822a8caa6)

## Write Database(Postgres)

![image](https://github.com/MohammedHydr/ecommerce-assessment/assets/93540731/00e883d5-33f4-4d72-ac71-46eefc7de24d)

### Customer
1. customerId: Auto-generated unique identifier for each customer.
2. name: Stores the name of the customer.
3. email: Stores the email of the customer.
4. phoneNumber: Stores the phone number of the customer with a maximum length of 15.
The Customer entity focuses on storing information that can identify and contact the customer. Each customer has a unique customerId, serving as a primary key and assisting in referencing orders related to them.
### Order
1. orderId: Auto-generated unique identifier for each order.
2. orderDate: Timestamp marking the date when the order was placed will be generated automatically when the order is created.
3. customer: A many-to-one relationship with the Customer entity.
4. orderItems: A one-to-many relationship with OrderItem.
5. totalPrice: Stores the total price of all items in the order, defined as a decimal with two decimal places and also it will be calculated based on the quantity and the products prices.
The Order entity establishes a many-to-one relationship with the Customer entity. It also contains multiple OrderItems, justifying a one-to-many relationship with the OrderItem entity. The totalPrice is calculated server-side before being persisted, thereby ensuring data integrity.
### OrderItem
1. itemId: Auto-generated unique identifier for each item in an order.
2. order: Many-to-one relationship with Order.
3. product: Many-to-one relationship with Product.
4. quantity: Number of units of the product.
5. price: The price at which the product was sold, preserved for historical accuracy will be taken from the product.
### Product
1. productId: Auto-generated unique identifier for each product.
2. name: Name of the product.
3. price: Price of the product, stored as a decimal.
4. stock: Number of items available in stock.
5. stockStatus: A boolean that indicates whether the item is in stock or not will be automatically updated based on the stock.

### Relationships and Normalization
* Customer to Order: One-to-Many
* A single customer can place multiple orders, while each order is associated with only one customer.
* Order to OrderItem: One-to-Many
* An order can contain multiple items, but each item belongs to only one order.
* Product to OrderItem: Many-to-One
* A single product can be part of multiple order items across different orders, but each order item is associated with only one product.
* The schema design aims for Third Normal Form (3NF), ensuring that all data is factually dependent only on the primary key. This has several benefits:
  * Elimination of Duplicate Data: Ensuring that each piece of data is stored only once, thereby reducing storage costs and improving data integrity.
  * Data Integrity: The use of foreign keys and relationships ensures that the data is consistent and reliable.
  * Logical Data Storage: Each piece of information is stored in its most logical place. For example, price is stored in OrderItem to maintain historical data even if the current price of the product changes.

## Read Database (MongoDb)
### Customer Collection
* Collection Name: customers
* Fields:
 * customer_id: Unique ID of the customer.
 * name: Name of the customer.
 * email: Email address of the customer.
 * phoneNumber: Phone number of the customer.
### Order Collection
* Collection Name: orders
* Fields:
 * order_id: Unique ID of the order.
 * orderDate: Date when the order was made.
 * customer: A reference to the Customer collection.
 * orderItems: List of items in the order.
 * totalPrice: Total price of the order.
### Product Collection
* Collection Name: products
* Fields:
 * product_id: Unique ID for the product.
 * name: Name of the product.
 * price: Price of the product.
 * stock: Stock level of the product.
 * stockStatus: A boolean indicating if the product is in stock.
### ProductSold Collection
* Collection Name: product_sold
* Fields:
 * id: Unique ID (usually generated by MongoDB).
 * productId: ID of the product that was sold.
 * productName: Name of the product sold.
 * productPrice: Price at which the product was sold.
 * quantitySold: Quantity of the product sold.
 * remainingStock: Remaining stock after the sale.
 * stockStatus: A boolean indicating stock status after the sale.
 * orderId: ID of the order in which the product was sold.
 * customerId: ID of the customer who bought the product.
 * productTotalPrice: Total price of the product sold (usually productPrice * quantitySold).
#### Key Points and Considerations
* Data Relationships and Normalization:
1. The Customer is related to the Order through a MongoDB DBRef, allowing for easy traversal and aggregation.
2. The OrderItem is embedded within the Order, enabling quick access to item-level details without additional queries.
3. Data Integrity and Redundancy:
ProductSold contains some redundant information (e.g., productName, productPrice) to avoid frequent joins and to maintain a historical record of prices and names at the time of sale.
4. Scalability:
MongoDB allows horizontal scaling through sharding, which could be particularly useful if any of the collections grow significantly in size.
5. Consumption in Query Microservice:
The product_sold collection would be particularly useful for analytics and can be populated by consuming events like ProductSold from the Kafka topics.
6. Data Access Patterns:
Given this schema design, various queries can be optimized for reading data, such as fetching all orders for a customer, all sales of a product, etc.
7. Event Sourcing:
This schema is geared for optimal query performance, as it should be, being part of a CQRS (Command Query Responsibility Segregation) and event-sourced 
architecture. Changes in these collections are typically triggered by consuming events from Kafka topics.

## Admin RestApi

